/* 
Euler 1

If we list all the natural numbers below 10 that are multiples of 3 or 5, 
we get 3, 5, 6 and 9. 
The sum of these multiples is 23.
Find the sum of all the multiples of 3 or 5 below 1000. */

#include <stdio.h>
int main(){
	int sum=0; // soma dos múltiplos.

	
	for(int i=3; i<1000; i++){ // para "i" de 3 a 999.
		if(i%3 == 0 || i%5 == 0){ // se "i" for divisível por 3 ou 5, 
			sum += i; //sum é incrementada pelo valor de "i".
		}
	}

	// imprime a soma de todos os multiplos de 3 ou 5 menor que 1000.
	printf("%d\n", sum);

	return 0;
}










/*
Euler 2

Each new term in the Fibonacci sequence is generated by adding the previous two terms.
By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, 
find the sum of the even-valued terms.

*/

#include <stdio.h>
int main(){
	int fibo, fiboN, sum, aux;
	fibo = 1; // primeiro número Fibonacci.
	fiboN = 2; // segundo número Fibonacci
	sum = 0;   // soma de todos os números Fibonnacci pares e menores que 4.000.000.

	while(fiboN < 4000000){ //enquanto o ultimo termo for menor que 4.000.000
		if(fiboN%2==0){  // se o termo n+1 for par
			sum += fiboN;	// sum é incrementada pelo termo.
		}
		aux = fibo;		
		fibo = fiboN;
		fiboN += aux; // fiboN = aux + fiboN.

	}

	// imprime a soma de todos os numeros Fibonacci pares menores que 4.000.000.
	printf("%d\n", sum);

	return 0;
}









/*
Euler 3

The prime factors of 13195 are 5, 7, 13 and 29.

What is the largest prime factor of the number 600851475143 ?
*/

#include <stdio.h>

int main(){
	long long int number=600851475143; // número para análise.
	int largest; // maior fator primo;
	int i=3; // variável de controle 
	
	while(1){
		while(number%i==0){ //Enquanto o número for divisível por i.
			number /= i;    // número = número/i.
			largest = i;
		}
		if(number==1)       // se número = 1
			break;
		i += 2;             // i = i + 2, pois números pares não precisam ser testados.

	}

	// imprime maior fator primo de number.
	printf("%d\n", largest);

	return 0;
}









/*
Euler 4

A palindromic number reads the same both ways. The largest palindrome made from the 
product of two 2-digit numbers is 9009 = 91 × 99.

Find the largest palindrome made from the product of two 3-digit numbers.

*/

#include <stdio.h>

// função para testar se número é palindromo.
int isPalindrome(int a){ 
	int aux=0; // variavel para inverter numero.
	int num = a; // salva numero original em num.
	while(a!=0){ // enquanto numero for diferente de zero.
		aux = (aux*10)+(a%10); // aux recebe aux * 10 (adiciona nova casa decimal) + ultimo digito de a.
		a = a/10; // remove último dígito número original.
	}
	// se num for igual a aux o número é igual de traz pra frente e retorna 1
	if(num==aux){
		return 1;
	}else{            // se num for diferente de aux, num não é igual de tras pra frente e retorna 0.
		return 0;
	}

}	


int main(){
	int largest=0;
	// loop para multiplicar todos os numeros de 3 digitos.
	for(int i=999; i>99; i--){
		for(int j=999; j>99; j--){
			if((isPalindrome(i*j)==1) && (i*j)> largest){ // se i*j for palindromo e maior que largest:
				largest = i*j;  // largest recebe i*j.
			}
		}
	}
	// imprime maior palindromo da multiplicação de dois numeros de 3 digitos.
	printf("%d\n", largest); 
	return 0;
}









/*
Euler 5

2520 is the smallest number that can be divided by each of the numbers from 1 to 10
without any remainder.

What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
*/

#include <stdio.h>

//Função para checar se numero é divisivel pelo intervalo natural de 1 a 20.
int isDivisible1to20(int num){
	for(int i=2; i<20; i++){ // para i de 2 a 20 (2 porque todo numero é divisivel por 1).
		if(num%i != 0) // se num nao for divisivel por (ao menos um) i, return 0.
			return 0;
	}
	return 1; // se num for divisivel por todos os i's, return 1.
}

int main(){
	int num=20; // 20 é o menor numero que tem a possibilidade de ser divisivel pelo intervalo [1, 20].
	while(isDivisible1to20(num) != 1){ // enquanto a função isDivisible1to20 nao retornar 1
		num +=20; // incrementa num em 20, pois é o maior passo viável já que num tem que ser multiplo de 20.
	}	

	// imprime num
	printf("%d\n", num);


	return 0;
}